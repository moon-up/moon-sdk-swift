//
// OnramperAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class OnramperAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://vault-api.usemoon.ai")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// - POST /onramper/fund/${accountName}
    /// - API Key:
    /// - type: apiKey x-api-key 
    /// - name: ApiKeyAuth
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: BearerAuth
    /// - parameter authorization: (header)  
    /// - parameter accountName: (path)  
    /// - parameter transactionInput: (body)  
    /// - returns: AnyPublisher<Any, Error> 
    open func onRamperCheckout(authorization: String, accountName: String, transactionInput: TransactionInput) -> AnyPublisher<Any, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/onramper/fund/${accountName}"
                path = path.replacingOccurrences(of: "{accountName}", with: accountName)
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                var headers = [String: String]()
                headers["Authorization"] = authorization
                request.allHTTPHeaderFields = headers
                request.httpBody = try self.encoder.encode(transactionInput)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Any, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    if let object = try JSONSerialization.jsonObject(with: response.data, options: []) as? Any {
                        return object
                    } else {
                        throw OpenAPITransportError.invalidResponseMappingError(data: response.data)
                    }
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /onramper/quotes/buy
    /// - API Key:
    /// - type: apiKey x-api-key 
    /// - name: ApiKeyAuth
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: BearerAuth
    /// - parameter authorization: (header)  
    /// - parameter fiat: (query)  
    /// - parameter crypto: (query)  
    /// - parameter amount: (query)  
    /// - parameter paymentMethod: (query)  (optional, default to "creditcard")
    /// - parameter uuid: (query)  (optional, default to "")
    /// - parameter clientName: (query)  (optional, default to "")
    /// - parameter country: (query)  (optional, default to "")
    /// - returns: AnyPublisher<[Quote], Error> 
    open func onRamperGetQuotesBuy(authorization: String, fiat: String, crypto: String, amount: Double, paymentMethod: String? = nil, uuid: String? = nil, clientName: String? = nil, country: String? = nil) -> AnyPublisher<[Quote], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/onramper/quotes/buy"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "fiat", value: fiat))
                queryItems.append(URLQueryItem(name: "crypto", value: crypto))
                queryItems.append(URLQueryItem(name: "amount", value: "\(amount)"))
                if let paymentMethod = paymentMethod { queryItems.append(URLQueryItem(name: "paymentMethod", value: paymentMethod)) } 
                if let uuid = uuid { queryItems.append(URLQueryItem(name: "uuid", value: uuid)) } 
                if let clientName = clientName { queryItems.append(URLQueryItem(name: "clientName", value: clientName)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                var headers = [String: String]()
                headers["Authorization"] = authorization
                request.allHTTPHeaderFields = headers
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Quote], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([Quote].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /onramper/quotes/sell
    /// - API Key:
    /// - type: apiKey x-api-key 
    /// - name: ApiKeyAuth
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: BearerAuth
    /// - parameter authorization: (header)  
    /// - parameter fiat: (query)  
    /// - parameter crypto: (query)  
    /// - parameter amount: (query)  
    /// - parameter paymentMethod: (query)  (optional, default to "creditcard")
    /// - parameter uuid: (query)  (optional, default to "")
    /// - parameter clientName: (query)  (optional, default to "")
    /// - parameter country: (query)  (optional, default to "")
    /// - returns: AnyPublisher<[SellQuote], Error> 
    open func onRamperGetQuotesSell(authorization: String, fiat: String, crypto: String, amount: Double, paymentMethod: String? = nil, uuid: String? = nil, clientName: String? = nil, country: String? = nil) -> AnyPublisher<[SellQuote], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/onramper/quotes/sell"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "fiat", value: fiat))
                queryItems.append(URLQueryItem(name: "crypto", value: crypto))
                queryItems.append(URLQueryItem(name: "amount", value: "\(amount)"))
                if let paymentMethod = paymentMethod { queryItems.append(URLQueryItem(name: "paymentMethod", value: paymentMethod)) } 
                if let uuid = uuid { queryItems.append(URLQueryItem(name: "uuid", value: uuid)) } 
                if let clientName = clientName { queryItems.append(URLQueryItem(name: "clientName", value: clientName)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                var headers = [String: String]()
                headers["Authorization"] = authorization
                request.allHTTPHeaderFields = headers
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[SellQuote], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([SellQuote].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /onramper/assets
    /// - API Key:
    /// - type: apiKey x-api-key 
    /// - name: ApiKeyAuth
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: BearerAuth
    /// - parameter authorization: (header)  
    /// - parameter source: (query)  
    /// - parameter country: (query)  
    /// - returns: AnyPublisher<SupportedAssetResponse, Error> 
    open func onRamperGetSupportedAssets(authorization: String, source: String, country: String) -> AnyPublisher<SupportedAssetResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/onramper/assets"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "source", value: source))
                queryItems.append(URLQueryItem(name: "country", value: country))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                var headers = [String: String]()
                headers["Authorization"] = authorization
                request.allHTTPHeaderFields = headers
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SupportedAssetResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SupportedAssetResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /onramper/currencies
    /// - API Key:
    /// - type: apiKey x-api-key 
    /// - name: ApiKeyAuth
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: BearerAuth
    /// - parameter authorization: (header)  
    /// - parameter type: (query)  
    /// - returns: AnyPublisher<SupportedCurrenciesResponse, Error> 
    open func onRamperGetSupportedCurrencies(authorization: String, type: String) -> AnyPublisher<SupportedCurrenciesResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/onramper/currencies"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "type", value: type))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                var headers = [String: String]()
                headers["Authorization"] = authorization
                request.allHTTPHeaderFields = headers
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SupportedCurrenciesResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SupportedCurrenciesResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /onramper/defaults
    /// - API Key:
    /// - type: apiKey x-api-key 
    /// - name: ApiKeyAuth
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: BearerAuth
    /// - parameter authorization: (header)  
    /// - parameter country: (query)  
    /// - parameter type: (query)  
    /// - returns: AnyPublisher<SupportedDefaultResponse, Error> 
    open func onRamperGetSupportedDefaultsAll(authorization: String, country: String, type: String) -> AnyPublisher<SupportedDefaultResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/onramper/defaults"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "country", value: country))
                queryItems.append(URLQueryItem(name: "type", value: type))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                var headers = [String: String]()
                headers["Authorization"] = authorization
                request.allHTTPHeaderFields = headers
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SupportedDefaultResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SupportedDefaultResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /onramper/onramps
    /// - API Key:
    /// - type: apiKey x-api-key 
    /// - name: ApiKeyAuth
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: BearerAuth
    /// - parameter authorization: (header)  
    /// - returns: AnyPublisher<GetSupportedOnRampsResponse, Error> 
    open func onRamperGetSupportedOnRampsAll(authorization: String) -> AnyPublisher<GetSupportedOnRampsResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/onramper/onramps"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                var headers = [String: String]()
                headers["Authorization"] = authorization
                request.allHTTPHeaderFields = headers
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetSupportedOnRampsResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetSupportedOnRampsResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /onramper/payment-types
    /// - API Key:
    /// - type: apiKey x-api-key 
    /// - name: ApiKeyAuth
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: BearerAuth
    /// - parameter authorization: (header)  
    /// - parameter fiat: (query)  
    /// - parameter country: (query)  
    /// - parameter type: (query)  
    /// - returns: AnyPublisher<SupportedPaymentTypesCurrencyResponse, Error> 
    open func onRamperGetSupportedPaymentTypes(authorization: String, fiat: String, country: String, type: String) -> AnyPublisher<SupportedPaymentTypesCurrencyResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/onramper/payment-types"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "fiat", value: fiat))
                queryItems.append(URLQueryItem(name: "country", value: country))
                queryItems.append(URLQueryItem(name: "type", value: type))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                var headers = [String: String]()
                headers["Authorization"] = authorization
                request.allHTTPHeaderFields = headers
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SupportedPaymentTypesCurrencyResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SupportedPaymentTypesCurrencyResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /onramper/payment-types/fiat
    /// - API Key:
    /// - type: apiKey x-api-key 
    /// - name: ApiKeyAuth
    /// - API Key:
    /// - type: apiKey Authorization 
    /// - name: BearerAuth
    /// - parameter authorization: (header)  
    /// - parameter fiat: (query)  
    /// - parameter country: (query)  
    /// - returns: AnyPublisher<SupportedPaymentTypesCurrencyResponse, Error> 
    open func onRamperGetSupportedPaymentTypesFiat(authorization: String, fiat: String, country: String) -> AnyPublisher<SupportedPaymentTypesCurrencyResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/onramper/payment-types/fiat"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "fiat", value: fiat))
                queryItems.append(URLQueryItem(name: "country", value: country))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                var headers = [String: String]()
                headers["Authorization"] = authorization
                request.allHTTPHeaderFields = headers
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SupportedPaymentTypesCurrencyResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SupportedPaymentTypesCurrencyResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
