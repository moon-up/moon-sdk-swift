//
// IWebhook.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct IWebhook: Codable, JSONEncodable, Hashable {

    public var block: Block
    public var chainId: String
    public var logs: [Log]
    public var txs: [Transaction]
    public var txsInternal: [InternalTransaction]
    public var abi: [AbiItem]
    public var retries: Double
    public var confirmed: Bool
    public var tag: String
    public var streamId: String
    public var erc20Transfers: [IERC20Transfer]
    public var erc20Approvals: [IERC20Approval]
    public var nftTransfers: [INFTTransfer]
    public var nativeBalances: [INativeBalance]
    public var nftApprovals: IOldNFTApproval
    public var nftTokenApprovals: [INFTApproval]

    public init(block: Block, chainId: String, logs: [Log], txs: [Transaction], txsInternal: [InternalTransaction], abi: [AbiItem], retries: Double, confirmed: Bool, tag: String, streamId: String, erc20Transfers: [IERC20Transfer], erc20Approvals: [IERC20Approval], nftTransfers: [INFTTransfer], nativeBalances: [INativeBalance], nftApprovals: IOldNFTApproval, nftTokenApprovals: [INFTApproval]) {
        self.block = block
        self.chainId = chainId
        self.logs = logs
        self.txs = txs
        self.txsInternal = txsInternal
        self.abi = abi
        self.retries = retries
        self.confirmed = confirmed
        self.tag = tag
        self.streamId = streamId
        self.erc20Transfers = erc20Transfers
        self.erc20Approvals = erc20Approvals
        self.nftTransfers = nftTransfers
        self.nativeBalances = nativeBalances
        self.nftApprovals = nftApprovals
        self.nftTokenApprovals = nftTokenApprovals
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case block
        case chainId
        case logs
        case txs
        case txsInternal
        case abi
        case retries
        case confirmed
        case tag
        case streamId
        case erc20Transfers
        case erc20Approvals
        case nftTransfers
        case nativeBalances
        case nftApprovals
        case nftTokenApprovals
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(block, forKey: .block)
        try container.encode(chainId, forKey: .chainId)
        try container.encode(logs, forKey: .logs)
        try container.encode(txs, forKey: .txs)
        try container.encode(txsInternal, forKey: .txsInternal)
        try container.encode(abi, forKey: .abi)
        try container.encode(retries, forKey: .retries)
        try container.encode(confirmed, forKey: .confirmed)
        try container.encode(tag, forKey: .tag)
        try container.encode(streamId, forKey: .streamId)
        try container.encode(erc20Transfers, forKey: .erc20Transfers)
        try container.encode(erc20Approvals, forKey: .erc20Approvals)
        try container.encode(nftTransfers, forKey: .nftTransfers)
        try container.encode(nativeBalances, forKey: .nativeBalances)
        try container.encode(nftApprovals, forKey: .nftApprovals)
        try container.encode(nftTokenApprovals, forKey: .nftTokenApprovals)
    }
}

